{"version":3,"file":"client-js-sdk.cjs.production.min.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/modules/data.ts","../src/modules/events.ts","../src/util/http/HttpClientAxios.ts","../src/connectors/nacelleConnector.ts","../src/connectors/static/utils/getListHandles.ts","../src/connectors/static/utils/getList.ts","../src/objects/product.ts","../src/objects/media.ts","../src/objects/itemList.ts","../src/objects/collection.ts","../src/objects/content.ts","../src/objects/contentSection.ts","../src/util/createFieldsFromTags.ts","../src/objects/space.ts","../src/connectors/graphql/nacelleGraphQLConnector.ts","../src/modules/checkout.ts","../src/modules/status.ts","../src/modules/wishlist.ts","../src/connectors/static/utils/constructDataPath.ts","../src/connectors/static/utils/constructDataPathPrefix.ts","../src/connectors/static/nacelleStaticConnector.ts","../src/nacelle-client/index.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { NacelleConnector } from '../connectors/nacelleConnector'\nimport {\n  FetchProductParams,\n  FetchProductsParams,\n  FetchCollectionParams,\n  FetchCollectionPageParams,\n  FetchContentParams,\n  FetchPageParams,\n  FetchPagesParams,\n  FetchArticleParams,\n  FetchArticlesParams,\n  FetchBlogParams,\n  FetchBlogPageParams,\n} from '../connectors/interfaces/parameters'\nimport { Product } from '../objects/product'\nimport { Collection } from '../objects/collection'\nimport { Content } from '../objects/content'\nimport { Space } from '../objects/space'\n\nexport interface NacelleDataParams {\n  connector: NacelleConnector\n  locale?: string\n  currencyCode?: string\n  onDataError?: <T>(options: OnDataErrorParams) => Promise<T> | T\n}\n\nexport interface NacelleDataUpdateParams {\n  connector?: NacelleConnector\n  locale?: string\n  currencyCode?: string\n  onDataError?: <T>(options: OnDataErrorParams) => Promise<T> | T\n}\n\ninterface AfterSubscription {\n  method: string\n  callback: <T>(responseObj: T) => Promise<T> | T\n}\n\ninterface OnDataErrorParams {\n  method: string\n  params: any\n  error: Error\n}\n\ninterface OnDataError {\n  <T>(options: OnDataErrorParams): Promise<T> | T\n}\n\nexport default class NacelleData {\n  connector: NacelleConnector\n  locale: string\n  currencyCode: string\n  afterSubscriptions: AfterSubscription[]\n  onDataError: OnDataError | null\n\n  constructor(params: NacelleDataParams) {\n    this.connector = params.connector\n    this.locale = params.locale || 'en-us'\n    this.currencyCode = params.currencyCode || 'USD'\n    this.afterSubscriptions = []\n    this.onDataError = null\n\n    if (params.onDataError) {\n      this.onDataError = params.onDataError\n    }\n\n    this.connector.updateDefaults({\n      locale: this.locale,\n    })\n  }\n\n  update(params: NacelleDataUpdateParams) {\n    if (params.connector) {\n      this.connector = params.connector\n    }\n\n    if (params.locale) {\n      this.locale = params.locale\n\n      this.connector.updateDefaults({\n        locale: this.locale,\n      })\n    }\n\n    if (params.currencyCode) {\n      this.currencyCode = params.currencyCode\n    }\n\n    if (typeof params.onDataError !== 'undefined') {\n      this.onDataError = params.onDataError\n    }\n  }\n\n  async product(\n    params: FetchProductParams,\n    connector?: NacelleConnector\n  ): Promise<Product> {\n    try {\n      let product: Product\n\n      if (connector) {\n        product = await connector.product(params)\n      } else {\n        product = await this.connector.product(params)\n      }\n\n      return this.applyAfter<Product>('product', product)\n    } catch (error) {\n      if (this.onDataError) {\n        return this.onDataError<Product>({\n          method: 'product',\n          params,\n          error,\n        })\n      }\n\n      throw error\n    }\n  }\n\n  async products(\n    params: FetchProductsParams,\n    connector?: NacelleConnector\n  ): Promise<Product[]> {\n    try {\n      let products: Product[]\n\n      if (connector) {\n        products = await connector.products(params)\n      } else {\n        products = await this.connector.products(params)\n      }\n\n      return this.applyAfter<Product[]>('products', products)\n    } catch (error) {\n      if (this.onDataError) {\n        return this.onDataError<Product[]>({\n          method: 'products',\n          params,\n          error,\n        })\n      }\n\n      throw error\n    }\n  }\n\n  async collection(\n    params: FetchCollectionParams,\n    connector?: NacelleConnector\n  ): Promise<Collection> {\n    try {\n      let collection: Collection\n\n      if (connector) {\n        collection = await connector.collection(params)\n      } else {\n        collection = await this.connector.collection(params)\n      }\n\n      return this.applyAfter<Collection>('collection', collection)\n    } catch (error) {\n      if (this.onDataError) {\n        return this.onDataError<Collection>({\n          method: 'collection',\n          params,\n          error,\n        })\n      }\n\n      throw error\n    }\n  }\n\n  async collectionPage(\n    params: FetchCollectionPageParams,\n    connector?: NacelleConnector\n  ): Promise<Product[]> {\n    try {\n      let products: Product[]\n      if (connector) {\n        products = await connector.collectionPage(params)\n      } else {\n        products = await this.connector.collectionPage(params)\n      }\n\n      return this.applyAfter<Product[]>('collectionPage', products)\n    } catch (error) {\n      if (this.onDataError) {\n        return this.onDataError<Product[]>({\n          method: 'collectionPage',\n          params,\n          error,\n        })\n      }\n\n      throw error\n    }\n  }\n\n  async content(\n    params: FetchContentParams,\n    connector?: NacelleConnector\n  ): Promise<Content> {\n    try {\n      let content: Content\n\n      if (connector) {\n        content = await connector.content(params)\n      } else {\n        content = await this.connector.content(params)\n      }\n\n      return this.applyAfter<Content>('content', content)\n    } catch (error) {\n      if (this.onDataError) {\n        return this.onDataError<Content>({\n          method: 'content',\n          params,\n          error,\n        })\n      }\n\n      throw error\n    }\n  }\n\n  async page(\n    params: FetchPageParams,\n    connector?: NacelleConnector\n  ): Promise<Content> {\n    try {\n      let page: Content\n\n      if (connector) {\n        page = await connector.page(params)\n      } else {\n        page = await this.connector.page(params)\n      }\n\n      return this.applyAfter<Content>('page', page)\n    } catch (error) {\n      if (this.onDataError) {\n        return this.onDataError<Content>({\n          method: 'page',\n          params,\n          error,\n        })\n      }\n\n      throw error\n    }\n  }\n\n  async pages(\n    params: FetchPagesParams,\n    connector?: NacelleConnector\n  ): Promise<Content[]> {\n    try {\n      let pages: Content[]\n\n      if (connector) {\n        pages = await connector.pages(params)\n      } else {\n        pages = await this.connector.pages(params)\n      }\n\n      return this.applyAfter<Content[]>('pages', pages)\n    } catch (error) {\n      if (this.onDataError) {\n        return this.onDataError<Content[]>({\n          method: 'pages',\n          params,\n          error,\n        })\n      }\n\n      throw error\n    }\n  }\n\n  async article(\n    params: FetchArticleParams,\n    connector?: NacelleConnector\n  ): Promise<Content> {\n    try {\n      let article: Content\n\n      if (connector) {\n        article = await connector.article(params)\n      } else {\n        article = await this.connector.article(params)\n      }\n\n      return this.applyAfter<Content>('article', article)\n    } catch (error) {\n      if (this.onDataError) {\n        return this.onDataError<Content>({\n          method: 'article',\n          params,\n          error,\n        })\n      }\n\n      throw error\n    }\n  }\n\n  async articles(\n    params: FetchArticlesParams,\n    connector?: NacelleConnector\n  ): Promise<Content[]> {\n    try {\n      let articles: Content[]\n\n      if (connector) {\n        articles = await connector.articles(params)\n      } else {\n        articles = await this.connector.articles(params)\n      }\n\n      return this.applyAfter<Content[]>('articles', articles)\n    } catch (error) {\n      if (this.onDataError) {\n        return this.onDataError<Content[]>({\n          method: 'articles',\n          params,\n          error,\n        })\n      }\n\n      throw error\n    }\n  }\n\n  async blog(\n    params: FetchBlogParams,\n    connector?: NacelleConnector\n  ): Promise<Content> {\n    try {\n      let blog: Content\n\n      if (connector) {\n        blog = await connector.blog(params)\n      } else {\n        blog = await this.connector.blog(params)\n      }\n\n      return this.applyAfter<Content>('blog', blog)\n    } catch (error) {\n      if (this.onDataError) {\n        return this.onDataError<Content>({\n          method: 'blog',\n          params,\n          error,\n        })\n      }\n\n      throw error\n    }\n  }\n\n  async blogPage(\n    params: FetchBlogPageParams,\n    connector?: NacelleConnector\n  ): Promise<Content[]> {\n    try {\n      let articles: Content[]\n\n      if (connector) {\n        articles = await connector.blogPage(params)\n      } else {\n        articles = await this.connector.blogPage(params)\n      }\n\n      return this.applyAfter<Content[]>('blogPage', articles)\n    } catch (error) {\n      if (this.onDataError) {\n        return this.onDataError<Content[]>({\n          method: 'blogPage',\n          params,\n          error,\n        })\n      }\n\n      throw error\n    }\n  }\n\n  async space(connector?: NacelleConnector): Promise<Space> {\n    try {\n      let space: Space\n\n      if (connector) {\n        space = await connector.space()\n      } else {\n        space = await this.connector.space()\n      }\n\n      return this.applyAfter<Space>('space', space)\n    } catch (error) {\n      if (this.onDataError) {\n        return this.onDataError<Space>({\n          method: 'space',\n          params: {},\n          error,\n        })\n      }\n\n      throw error\n    }\n  }\n\n  async allProducts(\n    params?: { limit?: number },\n    connector?: NacelleConnector\n  ): Promise<Product[]> {\n    try {\n      let products: Product[]\n\n      if (connector) {\n        products = await connector.allProducts(params)\n      } else {\n        products = await this.connector.allProducts(params)\n      }\n\n      return this.applyAfter<Product[]>('allProducts', products)\n    } catch (error) {\n      if (this.onDataError) {\n        return this.onDataError<Product[]>({\n          method: 'allProducts',\n          params,\n          error,\n        })\n      }\n\n      throw error\n    }\n  }\n\n  async allCollections(\n    params?: { limit?: number },\n    connector?: NacelleConnector\n  ): Promise<Collection[]> {\n    try {\n      let collections: Collection[]\n\n      if (connector) {\n        collections = await connector.allCollections(params)\n      } else {\n        collections = await this.connector.allCollections(params)\n      }\n\n      return this.applyAfter<Collection[]>('allCollections', collections)\n    } catch (error) {\n      if (this.onDataError) {\n        return this.onDataError<Collection[]>({\n          method: 'allCollections',\n          params,\n          error,\n        })\n      }\n\n      throw error\n    }\n  }\n\n  async allContent(\n    params?: { limit?: number },\n    connector?: NacelleConnector\n  ): Promise<Content[]> {\n    try {\n      let content: Content[]\n\n      if (connector) {\n        content = await connector.allContent(params)\n      } else {\n        return this.connector.allContent(params)\n      }\n\n      return this.applyAfter<Content[]>('allContent', content)\n    } catch (error) {\n      if (this.onDataError) {\n        return this.onDataError<Content[]>({\n          method: 'allContent',\n          params,\n          error,\n        })\n      }\n\n      throw error\n    }\n  }\n\n  after(method: string, callback: <T>(responseObj: T) => Promise<T> | T): void {\n    this.afterSubscriptions.push({\n      method,\n      callback,\n    })\n  }\n\n  private async applyAfter<T>(method: string, responseObj: T): Promise<T> {\n    let response = responseObj\n    const subs = this.afterSubscriptions.filter((sub) => sub.method === method)\n\n    for (const sub of subs) {\n      response = await sub.callback<T>(response)\n    }\n\n    return response\n  }\n}\n","import HttpClient from '../util/http/HttpClient'\nimport HttpClientAxios from '../util/http/HttpClientAxios'\n\nexport interface NacelleEventsParams {\n  endpoint?: string\n  httpClient?: HttpClient\n  disable?: boolean\n}\n\nexport interface EventSubscription {\n  eventType: string\n  callback: (event: EventObject) => EventObject | null\n}\n\nexport interface EventInput {\n  eventType: EventType | string\n  spaceId: string\n  url?: string\n  metafields?: string[]\n  value?: MonetaryValue\n  cart?: CartItem[]\n  user?: User\n  [key: string]: any\n}\n\nexport interface EventUrl {\n  url?: string\n  domain: string\n  route: string\n  urlParams?: string[]\n}\n\nexport interface GlobalEventData {\n  sessionEventCount?: number\n  attributionType?: EventType | string\n  attributionData?: Record<string, unknown>\n}\n\nexport interface EventObject extends EventInput, EventUrl, GlobalEventData {}\n\nexport interface CartItem {\n  productId: string\n  variantHandle: string\n  value: MonetaryValue\n}\n\n/**\n * Monetary value of an event\n * @property {number} amount - Amount in cents. Example: 3599 to represent $35.99\n * @property {string} currency - Currency string. Example: 'USD'\n */\nexport interface MonetaryValue {\n  amount: number\n  currency: string\n}\n\nexport interface User {\n  id?: string\n  anonymousId?: string\n  device?: string\n  ip?: string\n  email?: string\n  phone?: string\n}\n\nexport enum EventType {\n  productView = 'productView',\n  search = 'search',\n  productRecommendation = 'productRecommendation',\n  pageView = 'pageView',\n  collectionView = 'collectionView',\n  blogView = 'blogView',\n  articleView = 'articleView',\n  cartAdd = 'cartAdd',\n  cartRemove = 'cartRemove',\n  checkoutInit = 'checkoutInit',\n  checkoutComplete = 'checkoutComplete',\n}\n\nexport default class NacelleEvents {\n  endpoint: string\n  apiClient: HttpClient\n  disable: boolean\n  subscriptions: EventSubscription[]\n  attributionEvents: {\n    [key: string]: (attributionEvent: EventObject) => Record<string, unknown>\n  }\n\n  constructor(params?: NacelleEventsParams) {\n    if (params && params.endpoint && params.endpoint.length > 0) {\n      this.endpoint = params.endpoint\n    } else if (\n      process &&\n      process.env &&\n      process.env.NACELLE_TEM_ENDPOINT &&\n      process.env.NACELLE_TEM_ENDPOINT.length > 0\n    ) {\n      this.endpoint = process.env.NACELLE_TEM_ENDPOINT\n    } else {\n      // Set default TEM endpoint\n      this.endpoint = 'https://tem.hailfrequency.com/events/add'\n    }\n\n    this.apiClient =\n      params && params.httpClient ? params.httpClient : new HttpClientAxios()\n\n    if (params && typeof params.disable !== 'undefined') {\n      this.disable = params.disable\n    } else {\n      this.disable = false\n    }\n\n    this.subscriptions = []\n    this.attributionEvents = {}\n  }\n\n  log(eventInput: EventInput): void {\n    if (this.disable) {\n      return\n    }\n\n    updateSessionEventCount()\n\n    const event: EventObject = {\n      ...eventInput,\n      user: {\n        device: getDevice(),\n        ...eventInput.user,\n      },\n      ...getUrlParts(eventInput.url),\n      ...getGlobalEventData(),\n    }\n\n    const getAttributionData = this.attributionEvents[event.eventType]\n    if (getAttributionData) {\n      setGlobalEventData({\n        attributionType: event.eventType,\n        attributionData: getAttributionData(event),\n      })\n    }\n\n    const modifiedEvent = this.subscriptions\n      .filter(\n        ({ eventType }) => event.eventType === eventType || eventType === '*'\n      )\n      .filter(({ callback }) => !!callback)\n      .map(({ callback }) => callback(event))\n      .reduce((acc, cur) => ({ ...acc, ...cur }), {})\n\n    const eventToSend: EventObject = {\n      ...event,\n      ...modifiedEvent,\n    }\n\n    this.apiClient.post(this.endpoint, eventToSend)\n  }\n\n  onAttributionEvent(\n    eventType: string,\n    getAttributionData: (event: EventObject) => Record<string, unknown>\n  ): void {\n    this.attributionEvents[eventType] = getAttributionData\n  }\n\n  onEvent(\n    eventType: string,\n    callback: (event: EventObject) => EventObject\n  ): void {\n    this.subscriptions.push({\n      eventType,\n      callback,\n    })\n  }\n}\n\nconst getDevice = (): string => {\n  const globalScope = getGlobalScope()\n  const device =\n    globalScope && globalScope.navigator && globalScope.navigator.userAgent\n      ? globalScope.navigator.userAgent.toLowerCase()\n      : 'unknown'\n  return device\n}\n\nconst getUrlParts = (url: string | undefined): EventUrl => {\n  const globalScope = getGlobalScope()\n  const href = globalScope && globalScope.location && globalScope.location.href\n  const parsedUrl = tryCatch(\n    () => new URL(url || ''),\n    () =>\n      tryCatch(\n        () => new URL(href || ''),\n        () => undefined\n      )\n  ) as URL | undefined\n  const urlParams = parsedUrl\n    ? parsedUrl.search\n        .replace(/^\\?/g, '')\n        .split('&')\n        .filter((x) => !!x && x.length)\n    : []\n\n  return {\n    url: parsedUrl ? parsedUrl.toString() : '',\n    domain: parsedUrl ? parsedUrl.hostname : '',\n    route: parsedUrl ? parsedUrl.pathname : '',\n    urlParams,\n  }\n}\n\nconst getGlobalScope = (): {\n  nacelleEventData?: GlobalEventData\n  navigator?: { userAgent: string }\n  location?: { href: string }\n} => {\n  const globalScope = tryCatch(\n    // eslint-disable-next-line no-undef\n    () => globalThis,\n    () =>\n      tryCatch(\n        () => window,\n        () =>\n          tryCatch(\n            () => global,\n            () => undefined\n          )\n      )\n  ) as {\n    nacelleEventData?: GlobalEventData\n  }\n\n  return globalScope\n}\n\nconst getGlobalEventData = (): GlobalEventData => {\n  const globalScope = getGlobalScope()\n  const eventData = (globalScope && globalScope.nacelleEventData) || {}\n  return eventData\n}\n\nconst setGlobalEventData = (data: GlobalEventData): void => {\n  const globalScope = getGlobalScope()\n  if (!globalScope) {\n    return\n  }\n\n  globalScope.nacelleEventData = {\n    ...globalScope.nacelleEventData,\n    ...data,\n  }\n}\n\nconst updateSessionEventCount = () => {\n  const globalEventData = getGlobalEventData()\n  setGlobalEventData({\n    sessionEventCount: (globalEventData.sessionEventCount || 0) + 1,\n  })\n}\n\nconst tryCatch = (tryFunc: Function, catchFunc: Function): any => {\n  try {\n    return tryFunc()\n  } catch (error) {\n    return catchFunc(error)\n  }\n}\n","import axios, { AxiosRequestConfig, AxiosInstance } from 'axios'\nimport HttpClient from './HttpClient'\nimport HttpClientReponse from './HttpClientResponse'\n\nexport default class HttpClientAxios implements HttpClient {\n  client: AxiosInstance\n\n  constructor(options?: AxiosRequestConfig) {\n    this.client = axios.create({\n      responseType: 'json',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      timeout: 240000,\n      maxContentLength: 524328890,\n      ...options,\n    })\n  }\n\n  get<T>(url: string): Promise<HttpClientReponse<T>> {\n    return this.client.get(url)\n  }\n\n  post<T>(url: string, data: object): Promise<HttpClientReponse<T>> {\n    return this.client.post(url, data)\n  }\n}\n","import HttpClient from '../util/http/HttpClient'\nimport HttpClientAxios from '../util/http/HttpClientAxios'\nimport { Product } from '../objects/product'\nimport { Collection } from '../objects/collection'\nimport { Content } from '../objects/content'\nimport { Space } from '../objects/space'\nimport {\n  FetchProductParams,\n  FetchProductsParams,\n  FetchCollectionParams,\n  FetchCollectionPageParams,\n  FetchContentParams,\n  FetchPageParams,\n  FetchPagesParams,\n  FetchBlogParams,\n  FetchArticleParams,\n  FetchArticlesParams,\n  FetchBlogPageParams,\n  UpdateParams,\n} from './interfaces/parameters'\n\nexport interface NacelleConnectorParams {\n  locale?: string\n  httpClient?: HttpClient\n}\n\nexport class NacelleConnector {\n  apiClient: HttpClient\n  locale: string\n\n  constructor(params?: NacelleConnectorParams) {\n    this.apiClient =\n      params && params.httpClient ? params.httpClient : new HttpClientAxios()\n    this.locale = params && params.locale ? params.locale : 'en-us'\n  }\n\n  updateDefaults(params?: UpdateParams) {\n    if (params && params.locale) {\n      this.locale = params.locale\n    }\n  }\n\n  async product(_options: FetchProductParams): Promise<Product> {\n    throw new Error('The default NacelleConnector does not return a product')\n  }\n\n  async products(_options: FetchProductsParams): Promise<Product[]> {\n    throw new Error('The default NacelleConnector does not return products')\n  }\n\n  async collection(_options: FetchCollectionParams): Promise<Collection> {\n    throw new Error('The default NacelleConnector does not return a collection')\n  }\n\n  async collectionPage(\n    _options: FetchCollectionPageParams\n  ): Promise<Product[]> {\n    throw new Error(\n      'The default NacelleConnector does not return a collection page'\n    )\n  }\n\n  async content(_options: FetchContentParams): Promise<Content> {\n    throw new Error('This NacelleConnector does not return a content item')\n  }\n\n  async page(_options: FetchPageParams): Promise<Content> {\n    throw new Error('This NacelleConnector does not return a page item')\n  }\n\n  async pages(_options: FetchPagesParams): Promise<Content[]> {\n    throw new Error('This NacelleConnector does not return pages')\n  }\n\n  async blog(_options: FetchBlogParams): Promise<Content> {\n    throw new Error('This NacelleConnector does not return a blog')\n  }\n\n  async article(_options: FetchArticleParams): Promise<Content> {\n    throw new Error('This NacelleConnector does not return an article')\n  }\n\n  async articles(_options: FetchArticlesParams): Promise<Content[]> {\n    throw new Error('This NacelleConnector does not return an article')\n  }\n\n  async blogPage(_options: FetchBlogPageParams): Promise<Content[]> {\n    throw new Error('This NacelleConnector does not return a blog page')\n  }\n\n  async space(): Promise<Space> {\n    throw new Error('This NacelleConnector does not return a space')\n  }\n\n  async allProducts(_options?: { limit?: number }): Promise<Product[]> {\n    throw new Error('This NacelleConnector does not return all products')\n  }\n\n  async allCollections(_options?: { limit?: number }): Promise<Collection[]> {\n    throw new Error('This NacelleConnector does not return all collections')\n  }\n\n  async allContent(_options?: { limit?: number }): Promise<Content[]> {\n    throw new Error('This NacelleConnector does not return all content')\n  }\n}\n","import getList from './getList'\nimport { ItemList } from '../../../objects/itemList'\n\ninterface GetListHandlesOptions {\n  paginate?: boolean\n  selectedList?: string\n  index?: number\n  itemsPerPage?: number\n}\n\nexport default (\n  lists: Array<ItemList>,\n  options: GetListHandlesOptions = {}\n): Array<string> => {\n  const { paginate, selectedList, index = 0, itemsPerPage = 30 } = options\n  const list = getList(selectedList, lists)\n\n  if (list && list.handles) {\n    if (paginate) {\n      return list.handles.slice(index, index + itemsPerPage)\n    }\n\n    return list.handles\n  }\n\n  throw new Error('Selected list does not have array of handles')\n}\n","import { ItemList } from '../../../objects/itemList'\n\nexport default (selectedList = 'default', lists: Array<ItemList>): ItemList => {\n  const selected = lists.find(({ slug }) => slug === selectedList)\n  if (selected !== undefined) {\n    return selected\n  } else {\n    throw new Error('No default product list found')\n  }\n}\n","import { Media } from './media'\nimport { Metafield } from './metafield'\nimport { Variant } from './variant'\n\nexport interface ProductOptions {\n  id?: string\n  handle?: string\n  locale?: string\n  globalHandle?: string\n  pimSyncSourceDomain?: string\n  pimSyncSource?: string\n  pimSyncSourceProductId?: string\n  title?: string\n  description?: string\n  priceRange?: PriceRange\n  productType?: string\n  featuredMedia?: Media\n  availableForSale?: boolean\n  vendor?: string\n  tags?: Array<string>\n  media?: Array<Media>\n  metafields?: Array<Metafield>\n  variants?: Array<Variant>\n  createdAt?: number\n  updatedAt?: number\n  indexedAt?: number\n}\n\ninterface PriceRange {\n  min: string\n  max: string\n  currencyCode: string\n}\n\nexport interface Product {\n  id: string\n  handle: string\n  locale: string\n  globalHandle: string\n  pimSyncSourceDomain: string\n  pimSyncSource?: string\n  pimSyncSourceProductId?: string\n  title: string\n  description: string\n  priceRange: PriceRange\n  productType?: string\n  featuredMedia?: Media\n  availableForSale: boolean\n  vendor?: string\n  tags: Array<string>\n  media: Array<Media>\n  metafields: Array<Metafield>\n  variants: Array<Variant>\n  createdAt?: number\n  updatedAt?: number\n  indexedAt: number\n}\n\nexport const createProduct = (options: ProductOptions): Product => {\n  const product: Product = {\n    id: '',\n    handle: '',\n    locale: 'en-us',\n    globalHandle: '',\n    pimSyncSourceDomain: '',\n    title: '',\n    description: '',\n    priceRange: {\n      min: '0.0',\n      max: '0.0',\n      currencyCode: 'USD',\n    },\n    availableForSale: true,\n    tags: [],\n    media: [],\n    metafields: [],\n    variants: [],\n    indexedAt: 0,\n    ...options,\n  }\n\n  return product\n}\n","export interface MediaOptions {\n  id?: string\n  type?: string\n  src?: string\n  thumbnailSrc?: string\n  altText?: string\n}\n\nexport interface Media {\n  id: string\n  type: string\n  src: string\n  thumbnailSrc: string\n  altText: string\n}\n\nexport const createMedia = (options: MediaOptions): Media => {\n  return {\n    id: '',\n    type: 'image',\n    src: '',\n    thumbnailSrc: '',\n    altText: '',\n    ...options,\n  }\n}\n","export interface ItemList {\n  title: string\n  slug: string\n  locale: string\n  handles: Array<string>\n}\n\nexport interface CreateItemListOptions {\n  title?: string\n  slug?: string\n  locale?: string\n  handles?: Array<string>\n}\n\nexport const createItemList = (obj: CreateItemListOptions): ItemList => {\n  const list: ItemList = {\n    title: '',\n    slug: 'default',\n    locale: 'en-us',\n    handles: [],\n    ...obj,\n  }\n\n  return list\n}\n","import { Media, createMedia } from './media'\nimport { ItemList, createItemList } from './itemList'\nimport { Metafield } from './metafield'\n\nexport interface Collection {\n  id: string\n  handle: string\n  locale: string\n  globalHandle: string\n  pimSyncSourceDomain: string\n  pimSyncSource?: string\n  pimSyncSourceCollectionId?: string\n  title?: string\n  description?: string\n  featuredMedia?: Media\n  productLists: Array<ItemList>\n  createdAt?: number\n  updatedAt?: number\n  metafields: Array<Metafield>\n}\n\nexport interface CreateCollectionOptions {\n  id?: string\n  handle?: string\n  locale?: string\n  globalHandle?: string\n  pimSyncSourceDomain?: string\n  pimSyncSource?: string\n  pimSyncSourceCollectionId?: string\n  title?: string\n  description?: string\n  featuredMedia?: Media | null\n  productLists?: Array<ItemList>\n  createdAt?: number\n  updatedAt?: number\n  metafields?: Array<Metafield>\n}\n\nexport const createCollection = (obj: CreateCollectionOptions): Collection => {\n  const { productLists, featuredMedia, ...rest } = obj\n\n  const collection = {\n    id: '',\n    handle: '',\n    locale: 'en-us',\n    globalHandle: '',\n    pimSyncSourceDomain: '',\n    productLists: [] as ItemList[],\n    featuredMedia: null as Media | null,\n    ...rest,\n    metafields: obj.metafields || [],\n  }\n\n  if (productLists && Array.isArray(productLists)) {\n    collection.productLists = productLists.map((list) => {\n      return createItemList(list)\n    })\n  }\n\n  if (featuredMedia) {\n    collection.featuredMedia = createMedia(featuredMedia)\n  }\n\n  return collection as Collection\n}\n","import { Media, createMedia } from './media'\nimport { ItemList, createItemList } from './itemList'\nimport { Author } from './author'\nimport { ContentSection, mapContentSections } from './contentSection'\nimport { RelatedArticle } from './relatedArticle'\n\nexport interface Content {\n  id: string\n  handle: string\n  locale: string\n  globalHandle: string\n  cmsSyncSource: string\n  cmsSyncSourceDomain: string\n  cmsSyncSourceContentId?: string\n  type: string\n  title?: string\n  description?: string\n  sections?: ContentSection[]\n  tags?: Array<string>\n  fields?: object\n  articleLists?: Array<ItemList>\n  relatedArticles?: Array<RelatedArticle>\n  collectionHandle?: string\n  content?: string\n  contentHtml?: string\n  excerpt?: string\n  blogHandle?: string\n  featuredMedia?: Media\n  author?: Author\n  publishDate?: number\n  createdAt?: number\n  updatedAt?: number\n  indexedAt: number\n}\n\nexport interface CreateContentOptions {\n  id?: string\n  handle?: string\n  locale?: string\n  globalHandle?: string\n  cmsSyncSource?: string\n  cmsSyncSourceDomain?: string\n  cmsSyncSourceContentId?: string\n  type?: string\n  title?: string\n  description?: string\n  sections?: string | ContentSection[]\n  tags?: Array<string>\n  fields?: object\n  articleLists?: Array<ItemList> | null\n  relatedArticles?: Array<RelatedArticle>\n  collectionHandle?: string\n  content?: string\n  contentHtml?: string\n  excerpt?: string\n  blogHandle?: string\n  featuredMedia?: Media | null\n  author?: Author\n  publishDate?: number\n  createdAt?: number\n  updatedAt?: number\n  indexedAt?: number\n}\n\nexport const createContent = (obj: CreateContentOptions): Content => {\n  const { articleLists, featuredMedia, sections, ...rest } = obj\n  const content = {\n    id: '',\n    handle: '',\n    locale: '',\n    globalHandle: '',\n    cmsSyncSource: '',\n    cmsSyncSourceDomain: '',\n    cmsSyncSourceContentId: '',\n    type: 'content',\n    indexedAt: 0,\n    articleLists: null as null | ItemList[],\n    featuredMedia: null as null | Media,\n    relatedArticles: [],\n    ...rest,\n  } as Content\n\n  if (sections) {\n    content.sections = mapContentSections(sections, content.cmsSyncSource)\n  }\n\n  if (articleLists && Array.isArray(articleLists)) {\n    content.articleLists = articleLists.map((list: ItemList) => {\n      return createItemList(list)\n    })\n  }\n\n  if (featuredMedia) {\n    content.featuredMedia = createMedia(featuredMedia)\n  }\n\n  return content\n}\n","import createFieldsFromTags from '../util/createFieldsFromTags'\n\nexport interface ContentSection {\n  title?: string\n  handle?: string\n  cmsSyncSource?: string\n  contentHtml?: string\n  contentType?: string\n  tags?: string[]\n  [key: string]: any\n}\n\nexport const mapContentSections = (\n  sections: string | ContentSection[],\n  cmsSyncSource: string\n): ContentSection[] => {\n  const formattedSections =\n    typeof sections === 'string' ? JSON.parse(sections) : sections\n\n  if (Array.isArray(formattedSections)) {\n    return formattedSections.map((section) => {\n      if (section.tags) {\n        const fieldTags = createFieldsFromTags(section.tags)\n\n        return {\n          ...section,\n          ...fieldTags,\n          cmsSyncSource,\n        }\n      }\n\n      return {\n        ...section,\n        cmsSyncSource,\n      }\n    })\n  }\n\n  return []\n}\n","export default (tags: string[]): { [key: string]: string } => {\n  if (Array.isArray(tags)) {\n    const tagFields = tags.reduce((fields, tag) => {\n      if (tag.includes('field::')) {\n        const [, key, value] = tag.split('::')\n        fields[key] = value\n      }\n\n      return fields\n    }, {} as { [key: string]: string })\n\n    return {\n      ...tagFields,\n    }\n  }\n\n  return {}\n}\n","import { Metafield } from './metafield'\n\nexport interface Link {\n  title: string\n  to: string\n  type: string\n  links?: Array<Link>\n}\n\nexport interface Linklist {\n  handle: string\n  links: Array<Link>\n}\n\nexport interface Space {\n  id: string\n  name: string\n  domain: string\n  linklists: Array<Linklist>\n  metafields: Array<Metafield>\n}\n\nexport interface CreateSpaceOptions {\n  id?: string\n  name?: string\n  domain?: string\n  linklists?: Array<Linklist>\n  metafields?: Array<Metafield>\n}\n\nexport const createSpace = (obj: CreateSpaceOptions): Space => {\n  const { id, name, domain, linklists, metafields } = obj\n  const space = {\n    id: id || '',\n    name: name || '',\n    domain: domain || '',\n    linklists: Array.isArray(linklists) ? linklists : [],\n    metafields: Array.isArray(metafields) ? metafields : [],\n  }\n\n  return space\n}\n","import { NacelleConnector, NacelleConnectorParams } from '../nacelleConnector'\nimport {\n  FetchProductParams,\n  FetchProductsParams,\n  FetchCollectionParams,\n  FetchCollectionPageParams,\n  FetchContentParams,\n  FetchPageParams,\n  FetchPagesParams,\n  FetchBlogParams,\n  FetchArticleParams,\n  FetchArticlesParams,\n  FetchBlogPageParams,\n} from '../interfaces/parameters'\nimport HttpClientAxios from '../../util/http/HttpClientAxios'\nimport { GraphQLResponseRoot, GraphQLPageResponse } from './utils/interfaces'\nimport getListHandles from '../static/utils/getListHandles'\nimport { Product, ProductOptions, createProduct } from '../../objects/product'\nimport {\n  Collection,\n  CreateCollectionOptions,\n  createCollection,\n} from '../../objects/collection'\nimport {\n  Content,\n  CreateContentOptions,\n  createContent,\n} from '../../objects/content'\nimport { Space, CreateSpaceOptions, createSpace } from '../../objects/space'\nimport { CartItem, Checkout, CheckoutMetafield } from '../../objects/checkout'\nimport getProductsQuery from './queries/getProductsQuery'\nimport getCollectionsQuery from './queries/getCollectionsQuery'\nimport getContentQuery from './queries/getContentQuery'\nimport getSpaceQuery from './queries/getSpaceQuery'\nimport getCheckoutQuery from './queries/getCheckoutQuery'\nimport getVariantAvailabilityQuery from './queries/getVariantAvailabilityQuery'\nimport processCheckoutMutation from './mutations/processCheckoutMutation'\nimport getProductByHandleQuery from './queries/getProductByHandleQuery'\nimport getCollectionByHandleQuery from './queries/getCollectionByHandleQuery'\nimport getContentByHandleQuery from './queries/getContentByHandleQuery'\n\nexport interface NacelleGraphQLConnectorParams extends NacelleConnectorParams {\n  endpoint: string\n  spaceId: string\n  token: string\n}\n\nexport interface NacelleGraphQLRequestResponse<T> {\n  success: boolean\n  data: T | null\n  error?: string\n}\n\nexport interface ProcessCheckoutParams {\n  cartItems: CartItem[]\n  checkoutId: string\n  metafields: CheckoutMetafield[]\n  note: string\n}\n\nexport default class NacelleGraphQLConnector extends NacelleConnector {\n  endpoint: string\n  spaceId: string\n  token: string\n\n  constructor(params: NacelleGraphQLConnectorParams) {\n    super(params)\n\n    if (\n      typeof params.endpoint === 'undefined' ||\n      params.endpoint === null ||\n      params.endpoint === ''\n    ) {\n      throw new Error('NacelleGraphQLConnector requires a valid endpoint.')\n    }\n\n    if (\n      typeof params.spaceId === 'undefined' ||\n      params.spaceId === null ||\n      params.spaceId === ''\n    ) {\n      throw new Error(\n        'NacelleGraphQLConnector requires a valid Nacelle space id.'\n      )\n    }\n\n    if (\n      typeof params.token === 'undefined' ||\n      params.token === null ||\n      params.token === ''\n    ) {\n      throw new Error(\n        'NacelleGraphQLConnector requires a valid Nacelle space API token.'\n      )\n    }\n\n    this.endpoint = params.endpoint\n    this.spaceId = params.spaceId\n    this.token = params.token\n\n    this.apiClient =\n      params && params.httpClient\n        ? params.httpClient\n        : new HttpClientAxios({\n            headers: {\n              'Content-Type': 'application/json',\n              'x-nacelle-space-id': this.spaceId,\n              'x-nacelle-space-token': this.token,\n            },\n          })\n  }\n\n  async request<T>(\n    query: string,\n    queryName: string,\n    variables?: any\n  ): Promise<NacelleGraphQLRequestResponse<T>> {\n    try {\n      const data = {\n        query,\n        variables,\n      }\n      const response = await this.apiClient.post<GraphQLResponseRoot>(\n        this.endpoint,\n        data\n      )\n\n      if (response) {\n        if (\n          response.data &&\n          Array.isArray(response.data.errors) &&\n          response.data.errors.length > 0\n        ) {\n          const firstError = response.data.errors.pop()\n\n          if (firstError && firstError.message) {\n            throw new Error(firstError.message)\n          }\n\n          throw new Error(`Unknown graphql error attempting ${queryName}`)\n        }\n\n        if (\n          response.data.data &&\n          typeof response.data.data[queryName] !== 'undefined'\n        ) {\n          return {\n            success: true,\n            data: response.data.data[queryName],\n          }\n        } else {\n          throw new Error(\n            `Response did not include ${queryName}.\n            ${JSON.stringify(response.data, null, 2)}`\n          )\n        }\n      }\n\n      throw new Error(`No valid response from ${queryName}`)\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message,\n        data: null,\n      }\n    }\n  }\n\n  async getAllPageItems<T>(params: {\n    query: string\n    queryName: string\n    first?: number\n  }): Promise<Array<T>> {\n    let after = ''\n    const pages = []\n\n    do {\n      const response = await this.request<GraphQLPageResponse<T>>(\n        params.query,\n        params.queryName,\n        {\n          first: params.first || 500,\n          after,\n        }\n      )\n\n      if (response.success && response.data) {\n        const page = response.data\n\n        pages.push(page)\n        after = page.nextToken\n      } else {\n        after = ''\n      }\n    } while (after !== '')\n\n    return pages.reduce((arr, page) => {\n      if (page && page.items && page.items.length > 0) {\n        return arr.concat(page.items)\n      }\n\n      return arr\n    }, [] as Array<T>)\n  }\n\n  async product(options: FetchProductParams): Promise<Product> {\n    const query = getProductByHandleQuery\n    const response = await this.request<GraphQLPageResponse<ProductOptions>>(\n      query,\n      'getProductByHandle',\n      {\n        handle: options.handle,\n        locale: options.locale || 'en-us',\n      }\n    )\n\n    if (response.success && response.data) {\n      return createProduct(response.data as ProductOptions)\n    }\n\n    throw new Error(response.error)\n  }\n\n  async products(options: FetchProductsParams): Promise<Product[]> {\n    const { handles, locale } = options\n    const useLocale = locale || this.locale\n\n    const requests = handles.map((handle) => {\n      return this.product({\n        handle,\n        locale: useLocale,\n      }).catch(() => {\n        return undefined\n      })\n    })\n\n    const responses = await Promise.all(requests)\n\n    const successes = responses.reduce((arr, response) => {\n      if (response) {\n        arr.push(response)\n      }\n\n      return arr\n    }, [] as Product[])\n\n    return successes\n  }\n\n  async collection(options: FetchCollectionParams): Promise<Collection> {\n    const query = getCollectionByHandleQuery\n    const response = await this.request<\n      GraphQLPageResponse<CreateCollectionOptions>\n    >(query, 'getCollectionByHandle', {\n      handle: options.handle,\n      locale: options.locale || 'en-us',\n    })\n\n    if (response.success && response.data) {\n      return createCollection(response.data as CreateCollectionOptions)\n    }\n\n    throw new Error(response.error)\n  }\n\n  async collectionPage(options: FetchCollectionPageParams): Promise<Product[]> {\n    const { handle, locale, list, paginate, index, itemsPerPage } = options\n    let { collection } = options\n\n    if (typeof collection === 'undefined') {\n      if (handle && handle.length > 0) {\n        collection = await this.collection({\n          handle,\n          locale,\n        })\n      } else {\n        throw new Error('A collection or handle is required')\n      }\n    }\n\n    const handles = getListHandles(collection.productLists, {\n      selectedList: list,\n      paginate: typeof paginate !== 'undefined' ? paginate : false,\n      index,\n      itemsPerPage,\n    })\n\n    return this.products({\n      handles,\n      locale,\n    })\n  }\n\n  async content({\n    handle,\n    type = 'page',\n    locale,\n    blogHandle = 'blog',\n  }: FetchContentParams): Promise<Content> {\n    const useLocale = locale || this.locale\n    const query = getContentByHandleQuery\n    const response = await this.request<\n      GraphQLPageResponse<CreateContentOptions>\n    >(query, 'getContentByHandle', {\n      type,\n      handle,\n      locale: useLocale,\n      blogHandle,\n    })\n\n    if (response.success && response.data) {\n      return createContent(response.data as CreateContentOptions)\n    }\n\n    throw new Error(response.error)\n  }\n\n  page(options: FetchPageParams): Promise<Content> {\n    return this.content({\n      handle: options.handle,\n      type: 'page',\n      locale: options.locale,\n    })\n  }\n\n  async pages(options: FetchPagesParams): Promise<Content[]> {\n    const { handles, locale } = options\n    const useLocale = locale || this.locale\n\n    const requests = handles.map((handle) => {\n      return this.content({\n        type: 'page',\n        handle,\n        locale: useLocale,\n      }).catch(() => {\n        return undefined\n      })\n    })\n\n    const responses = await Promise.all(requests)\n\n    const successes = responses.reduce((arr, response) => {\n      if (response) {\n        arr.push(response)\n      }\n\n      return arr\n    }, [] as Content[])\n\n    return successes\n  }\n\n  blog(options: FetchBlogParams): Promise<Content> {\n    return this.content({\n      handle: options.handle,\n      type: 'blog',\n      locale: options.locale,\n    })\n  }\n\n  article(options: FetchArticleParams): Promise<Content> {\n    return this.content({\n      handle: options.handle,\n      type: 'article',\n      locale: options.locale,\n      blogHandle: options.blogHandle || 'blog',\n    })\n  }\n\n  async articles(options: FetchArticlesParams): Promise<Content[]> {\n    const { handles, locale, blogHandle } = options\n    const useLocale = locale || this.locale\n\n    const requests = handles.map((handle) => {\n      return this.article({\n        handle,\n        blogHandle,\n        locale: useLocale,\n      }).catch(() => {\n        return undefined\n      })\n    })\n\n    const responses = await Promise.all(requests)\n\n    const successes = responses.reduce((arr, response) => {\n      if (response) {\n        arr.push(response)\n      }\n\n      return arr\n    }, [] as Content[])\n\n    return successes\n  }\n\n  async blogPage(options: FetchBlogPageParams): Promise<Content[]> {\n    const { handle, locale, list, paginate, index, itemsPerPage } = options\n    let { blog } = options\n\n    if (typeof blog === 'undefined') {\n      if (handle && handle.length > 0) {\n        blog = await this.blog({\n          handle,\n          locale,\n        })\n      } else {\n        throw new Error('A blog or handle is required')\n      }\n    }\n\n    if (blog.articleLists) {\n      const handles = getListHandles(blog.articleLists, {\n        selectedList: list,\n        paginate: typeof paginate !== 'undefined' ? paginate : false,\n        index,\n        itemsPerPage,\n      })\n\n      return this.articles({\n        handles,\n        locale,\n        blogHandle: handle || blog.handle,\n      })\n    }\n\n    return []\n  }\n\n  async allProducts(params?: { limit?: number }): Promise<Product[]> {\n    const query = getProductsQuery\n    const products = await this.getAllPageItems<ProductOptions>({\n      query,\n      queryName: 'getProducts',\n      first: params && params.limit ? params.limit : 2000,\n    })\n\n    return products.map((product) => createProduct(product))\n  }\n\n  async allCollections(params?: { limit?: number }): Promise<Collection[]> {\n    const query = getCollectionsQuery\n    const collections = await this.getAllPageItems<CreateCollectionOptions>({\n      query,\n      queryName: 'getCollections',\n      first: params && params.limit ? params.limit : 2000,\n    })\n\n    return collections.map((collection) => createCollection(collection))\n  }\n\n  async allContent(params?: { limit?: number }): Promise<Content[]> {\n    const query = getContentQuery\n    const content = await this.getAllPageItems<CreateContentOptions>({\n      query,\n      queryName: 'getContent',\n      first: params && params.limit ? params.limit : 2000,\n    })\n\n    return content.map((entry) => createContent(entry))\n  }\n\n  async space(): Promise<Space> {\n    const query = getSpaceQuery\n    const response = await this.request<CreateSpaceOptions>(query, 'getSpace')\n\n    if (response) {\n      if (response.success && response.data) {\n        return createSpace(response.data)\n      }\n\n      if (response && !response.success && response.error) {\n        throw new Error(response.error)\n      }\n    }\n\n    throw new Error('Invalid response attempting getSpace query')\n  }\n\n  async processCheckout(params: ProcessCheckoutParams): Promise<Checkout> {\n    const query = processCheckoutMutation\n    const response = await this.request<Checkout>(query, 'processCheckout', {\n      input: {\n        ...params,\n      },\n    })\n\n    if (response) {\n      if (response.success && response.data) {\n        return response.data\n      }\n\n      if (response && !response.success && response.error) {\n        throw new Error(response.error)\n      }\n    }\n\n    throw new Error('Invalid response attempting processCheckout mutation')\n  }\n\n  async queryCheckout(params: { id: string; url: string }): Promise<Checkout> {\n    const query = getCheckoutQuery\n    const response = await this.request<Checkout>(query, 'getCheckout', {\n      ...params,\n    })\n\n    if (response) {\n      if (response.success && response.data) {\n        return response.data\n      }\n\n      if (response && !response.success && response.error) {\n        throw new Error(response.error)\n      }\n    }\n\n    throw new Error('Invalid response attempting getCheckout query')\n  }\n\n  async isVariantAvailable(params: {\n    productId: string\n    variantId: string\n  }): Promise<boolean> {\n    const query = getVariantAvailabilityQuery\n    const response = await this.request<boolean>(\n      query,\n      'getVariantAvailability',\n      {\n        ...params,\n      }\n    )\n\n    if (response) {\n      if (\n        response.success &&\n        typeof response.data !== 'undefined' &&\n        response.data !== null\n      ) {\n        return response.data\n      }\n\n      if (response && !response.success && response.error) {\n        throw new Error(response.error)\n      }\n    }\n\n    throw new Error('Invalid response attempting getVariantAvailability query')\n  }\n}\n","import NacelleGraphQLConnector, {\n  ProcessCheckoutParams,\n} from '../connectors/graphql/nacelleGraphQLConnector'\nimport { Checkout } from '../objects/checkout'\n\ninterface NacelleCheckoutParams {\n  connector?: NacelleGraphQLConnector\n  endpoint?: string\n  spaceId?: string\n  token?: string\n}\n\nexport default class NacelleCheckout {\n  connector: NacelleGraphQLConnector\n\n  constructor(params: NacelleCheckoutParams) {\n    if (params.connector) {\n      this.connector = params.connector\n    } else if (params.endpoint && params.spaceId && params.token) {\n      this.connector = new NacelleGraphQLConnector({\n        endpoint: params.endpoint,\n        spaceId: params.spaceId,\n        token: params.token,\n      })\n    } else {\n      throw new Error('Missing parameters to initialize checkout module')\n    }\n  }\n\n  process(params: ProcessCheckoutParams): Promise<Checkout> {\n    return this.connector.processCheckout(params)\n  }\n\n  get(params: { id: string; url: string }): Promise<Checkout> {\n    if (typeof params.id === 'undefined' || params.id.length === 0) {\n      throw new Error(\n        'Missing parameter \"id\". Querying for a checkout requires a checkout Id.'\n      )\n    }\n\n    if (typeof params.url === 'undefined' || params.url.length === 0) {\n      throw new Error(\n        'Missing parameter \"url\". Querying for a checkout requires a checkout url.'\n      )\n    }\n\n    return this.connector.queryCheckout(params)\n  }\n}\n","import NacelleGraphQLConnector from '../connectors/graphql/nacelleGraphQLConnector'\n\ninterface NacelleStatusParams {\n  connector?: NacelleGraphQLConnector\n  endpoint?: string\n  spaceId?: string\n  token?: string\n}\n\nexport default class NacelleStatus {\n  connector: NacelleGraphQLConnector\n\n  constructor(params: NacelleStatusParams) {\n    if (params.connector) {\n      this.connector = params.connector\n    } else if (params.endpoint && params.spaceId && params.token) {\n      this.connector = new NacelleGraphQLConnector({\n        endpoint: params.endpoint,\n        spaceId: params.spaceId,\n        token: params.token,\n      })\n    } else {\n      throw new Error('Missing parameters to initialize checkout module')\n    }\n  }\n\n  isVariantAvailable(params: {\n    productId: string\n    variantId: string\n  }): Promise<boolean> {\n    return this.connector.isVariantAvailable(params)\n  }\n}\n","import HttpClient from '../util/http/HttpClient'\nimport HttpClientAxios from '../util/http/HttpClientAxios'\nimport { WishlistAxiosOptions } from '../objects/wishlist'\nimport {\n  GetWishlistParams,\n  PutWishlistParams,\n} from '../connectors/interfaces/parameters'\nimport getWishlistsByCustomerSourceIdQuery from '../connectors/graphql/queries/getWishlistsByCustomerSourceIdQuery'\nimport putWishlistMutation from '../connectors/graphql/mutations/putWishlistMutation'\n\nexport interface NacelleWishlistParams {\n  endpoint?: string\n  httpClient?: HttpClient\n  spaceId: string\n  token: string\n}\n\nexport default class NacelleWishlist {\n  endpoint: string\n  apiClient: HttpClient\n\n  constructor(params: NacelleWishlistParams) {\n    if (params && params.endpoint && params.endpoint.length > 0) {\n      this.endpoint = params.endpoint\n    } else if (\n      process &&\n      process.env &&\n      process.env.NACELLE_WISHLIST_ENDPOINT &&\n      process.env.NACELLE_WISHLIST_ENDPOINT.length > 0\n    ) {\n      this.endpoint = process.env.NACELLE_WISHLIST_ENDPOINT\n    } else {\n      // Set default Wishlist endpoint\n      this.endpoint = 'https://wishlist.hailfrequency.com/graphql'\n    }\n\n    const axiosOptions: WishlistAxiosOptions = {\n      headers: {\n        'Content-Type': 'application/json',\n        'X-Nacelle-Space-Id': params.spaceId,\n        'X-Nacelle-Space-Token': params.token,\n      },\n    }\n\n    this.apiClient =\n      params && params.httpClient\n        ? params.httpClient\n        : new HttpClientAxios(axiosOptions)\n  }\n\n  put(params: PutWishlistParams): Promise<any> {\n    return this.apiClient.post(this.endpoint, {\n      query: putWishlistMutation,\n      variables: { input: { ...params } },\n    })\n  }\n\n  get(params: GetWishlistParams): Promise<any> {\n    return this.apiClient.post(this.endpoint, {\n      query: getWishlistsByCustomerSourceIdQuery,\n      variables: params,\n    })\n  }\n}\n","import constructDataPathPrefix from './constructDataPathPrefix'\n\ninterface PathParams {\n  type: string\n  handle: string\n  locale: string\n  parentHandle?: string\n}\n\nconst defaultTypes = [\n  'product',\n  'collection',\n  'page',\n  'blog',\n  'article',\n  'content',\n]\n\nconst DELIMITER = '--'\n\nexport default (params: PathParams): string => {\n  const formattedLocal = params.locale.toLowerCase().replace('_', '-')\n  let path = `${params.handle}${DELIMITER}${formattedLocal}`\n\n  if (defaultTypes.indexOf(params.type) === -1) {\n    path = `${path}${DELIMITER}${params.type}`\n  }\n\n  const prefix = constructDataPathPrefix(params.type, params.parentHandle)\n\n  return `${prefix}${path}/static.json`\n}\n","export default (prefix: string, parentHandle?: string) => {\n  if (parentHandle === undefined || parentHandle === null) {\n    parentHandle = ''\n  } else {\n    parentHandle = `${parentHandle}/`\n  }\n\n  switch (prefix) {\n    case 'collection':\n      return `data/collections/${parentHandle}`\n    case 'page':\n      return `data/pages/${parentHandle}`\n    case 'product':\n      return `data/products/${parentHandle}`\n    case 'shop':\n      return `data/shop/${parentHandle}`\n    case 'article':\n      return `data/articles/${parentHandle}`\n    case 'blog':\n      return `data/blogs/${parentHandle}`\n    default:\n      return `data/content/${parentHandle}`\n  }\n}\n","import { NacelleConnector, NacelleConnectorParams } from '../nacelleConnector'\nimport {\n  FetchProductParams,\n  FetchProductsParams,\n  FetchCollectionParams,\n  FetchCollectionPageParams,\n  FetchContentParams,\n  FetchPageParams,\n  FetchPagesParams,\n  FetchBlogParams,\n  FetchArticleParams,\n  FetchArticlesParams,\n  FetchBlogPageParams,\n} from '../interfaces/parameters'\nimport { Product, ProductOptions, createProduct } from '../../objects/product'\nimport {\n  createCollection,\n  Collection,\n  CreateCollectionOptions,\n} from '../../objects/collection'\nimport {\n  createContent,\n  Content,\n  CreateContentOptions,\n} from '../../objects/content'\nimport constructDataPath from './utils/constructDataPath'\nimport getListHandles from './utils/getListHandles'\nimport { Space, CreateSpaceOptions, createSpace } from '../../objects/space'\n\nexport interface NacelleStaticConnectorParams extends NacelleConnectorParams {\n  basePath?: string\n}\n\nexport interface NacellStaticRequestResponse<T> {\n  success: boolean\n  data: T | null\n  error?: string\n}\n\nexport interface SearchStaticResponse {\n  products: Product[]\n  [key: string]: any\n}\n\ninterface OnErrorParams {\n  method: string\n  params: any\n  error: Error\n}\n\ninterface OnError {\n  <T>(options: OnErrorParams): Promise<T> | T\n}\n\nexport default class NacelleStaticConnector extends NacelleConnector {\n  basePath: string\n  onError?: OnError\n\n  constructor(params?: NacelleStaticConnectorParams) {\n    super(params)\n\n    this.basePath = params && params.basePath ? params.basePath : '/'\n  }\n\n  async request<T>(path: string): Promise<NacellStaticRequestResponse<T>> {\n    const url = `${this.basePath}${path}`\n\n    try {\n      const response = await this.apiClient.get<T>(url)\n\n      if (\n        response &&\n        response.data &&\n        response.headers &&\n        response.headers['content-type'].includes('application/json')\n      ) {\n        return {\n          success: true,\n          data: response.data,\n        }\n      }\n\n      throw new Error(`Unable to find static resource at ${url}`)\n    } catch (error) {\n      return {\n        success: false,\n        error: error.message,\n        data: null,\n      }\n    }\n  }\n\n  async requestMany<T>(paths: string[]): Promise<T[]> {\n    const requests = paths.map((path) => {\n      return this.request<T>(path)\n    })\n    const responses = await Promise.all(requests)\n    const successes = responses.reduce((arr, response) => {\n      if (response.success && response.data) {\n        arr.push(response.data)\n      }\n\n      return arr\n    }, [] as T[])\n\n    return successes\n  }\n\n  async product(options: FetchProductParams): Promise<Product> {\n    try {\n      const { handle, locale } = options\n      const useLocale = locale || this.locale\n      const path = constructDataPath({\n        type: 'product',\n        handle: handle,\n        locale: useLocale,\n      })\n      const response = await this.request<ProductOptions>(path)\n\n      if (response.success && response.data) {\n        return createProduct(response.data)\n      }\n\n      throw new Error(response.error)\n    } catch (error) {\n      if (this.onError) {\n        return this.onError<Product>({\n          method: 'product',\n          params: options,\n          error,\n        })\n      }\n      throw error\n    }\n  }\n\n  async products(options: FetchProductsParams): Promise<Product[]> {\n    const { handles, locale } = options\n    const useLocale = locale || this.locale\n\n    const requests = handles.map((handle) => {\n      return this.product({\n        handle,\n        locale: useLocale,\n      }).catch(() => {\n        return undefined\n      })\n    })\n\n    const responses = await Promise.all(requests)\n\n    const successes = responses.reduce((arr, response) => {\n      if (response) {\n        arr.push(response)\n      }\n\n      return arr\n    }, [] as Product[])\n\n    return successes\n  }\n\n  async collection(options: FetchCollectionParams): Promise<Collection> {\n    try {\n      const { handle, locale } = options\n      const useLocale = locale || this.locale\n      const path = constructDataPath({\n        type: 'collection',\n        handle: handle,\n        locale: useLocale,\n      })\n      const response = await this.request<CreateCollectionOptions>(path)\n\n      if (response.success && response.data) {\n        return createCollection(response.data)\n      }\n\n      throw new Error(response.error)\n    } catch (error) {\n      if (this.onError) {\n        return this.onError<Collection>({\n          method: 'collection',\n          params: options,\n          error,\n        })\n      }\n\n      throw error\n    }\n  }\n\n  async collectionPage(options: FetchCollectionPageParams): Promise<Product[]> {\n    try {\n      const { handle, locale, list, paginate, index, itemsPerPage } = options\n      let { collection } = options\n\n      if (typeof collection === 'undefined') {\n        if (handle && handle.length > 0) {\n          collection = await this.collection({\n            handle,\n            locale,\n          })\n        } else {\n          throw new Error('A collection or handle is required')\n        }\n      }\n\n      const handles = getListHandles(collection.productLists, {\n        selectedList: list,\n        paginate: typeof paginate !== 'undefined' ? paginate : false,\n        index,\n        itemsPerPage,\n      })\n\n      return this.products({\n        handles,\n        locale,\n      })\n    } catch (error) {\n      if (this.onError) {\n        return this.onError<Product[]>({\n          method: 'collectionPage',\n          params: options,\n          error,\n        })\n      }\n\n      throw error\n    }\n  }\n\n  async content({\n    handle,\n    type = 'page',\n    locale,\n    blogHandle = 'blog',\n  }: FetchContentParams): Promise<Content> {\n    try {\n      const useLocale = locale || this.locale\n      let path = constructDataPath({\n        type,\n        handle: handle,\n        locale: useLocale,\n      })\n\n      if (type === 'article') {\n        path = constructDataPath({\n          type,\n          handle: handle,\n          locale: useLocale,\n          parentHandle: blogHandle,\n        })\n      }\n\n      const response = await this.request<CreateContentOptions>(path)\n\n      if (response.success && response.data) {\n        return createContent(response.data)\n      }\n\n      throw new Error(response.error)\n    } catch (error) {\n      if (this.onError) {\n        return this.onError<Content>({\n          method: 'content',\n          params: { handle, type, locale, blogHandle },\n          error,\n        })\n      }\n\n      throw error\n    }\n  }\n\n  page(options: FetchPageParams): Promise<Content> {\n    return this.content({\n      handle: options.handle,\n      type: 'page',\n      locale: options.locale,\n    })\n  }\n\n  async pages(options: FetchPagesParams): Promise<Content[]> {\n    const { handles, locale } = options\n    const useLocale = locale || this.locale\n\n    const requests = handles.map((handle) => {\n      return this.content({\n        type: 'page',\n        handle,\n        locale: useLocale,\n      }).catch(() => {\n        return undefined\n      })\n    })\n\n    const responses = await Promise.all(requests)\n\n    const successes = responses.reduce((arr, response) => {\n      if (response) {\n        arr.push(response)\n      }\n\n      return arr\n    }, [] as Content[])\n\n    return successes\n  }\n\n  blog(options: FetchBlogParams): Promise<Content> {\n    return this.content({\n      handle: options.handle,\n      type: 'blog',\n      locale: options.locale,\n    })\n  }\n\n  article(options: FetchArticleParams): Promise<Content> {\n    return this.content({\n      handle: options.handle,\n      type: 'article',\n      locale: options.locale,\n      blogHandle: options.blogHandle || 'blog',\n    })\n  }\n\n  async articles(options: FetchArticlesParams): Promise<Content[]> {\n    const { handles, locale, blogHandle } = options\n    const useLocale = locale || this.locale\n\n    const requests = handles.map((handle) => {\n      return this.article({\n        handle,\n        blogHandle,\n        locale: useLocale,\n      }).catch(() => {\n        return undefined\n      })\n    })\n\n    const responses = await Promise.all(requests)\n\n    const successes = responses.reduce((arr, response) => {\n      if (response) {\n        arr.push(response)\n      }\n\n      return arr\n    }, [] as Content[])\n\n    return successes\n  }\n\n  async blogPage(options: FetchBlogPageParams): Promise<Content[]> {\n    try {\n      const { handle, locale, list, paginate, index, itemsPerPage } = options\n      let { blog } = options\n\n      if (typeof blog === 'undefined') {\n        if (handle && handle.length > 0) {\n          blog = await this.blog({\n            handle,\n            locale,\n          })\n        } else {\n          throw new Error('A blog or handle is required')\n        }\n      }\n\n      if (blog.articleLists) {\n        const handles = getListHandles(blog.articleLists, {\n          selectedList: list,\n          paginate: typeof paginate !== 'undefined' ? paginate : false,\n          index,\n          itemsPerPage,\n        })\n\n        return this.articles({\n          handles,\n          locale,\n          blogHandle: handle || blog.handle,\n        })\n      }\n\n      return []\n    } catch (error) {\n      if (this.onError) {\n        return this.onError<Content[]>({\n          method: 'blogPage',\n          params: options,\n          error,\n        })\n      }\n\n      throw error\n    }\n  }\n\n  async space(): Promise<Space> {\n    const path = 'data/space.json'\n    const response = await this.request<CreateSpaceOptions>(path)\n\n    if (response.success && response.data) {\n      return createSpace(response.data)\n    }\n\n    throw new Error(response.error)\n  }\n\n  async allProducts(): Promise<Product[]> {\n    const path = 'data/search.json'\n    const response = await this.request<SearchStaticResponse>(path)\n\n    if (response.success && response.data && response.data.products) {\n      return response.data.products.map((product) => createProduct(product))\n    }\n\n    if (response.error) {\n      throw new Error(response.error)\n    }\n\n    throw new Error('Unable to get all products from search.json static file.')\n  }\n}\n","import NacelleData from '../modules/data'\nimport NacelleCheckout from '../modules/checkout'\nimport NacelleStatus from '../modules/status'\nimport NacelleWishlist, { NacelleWishlistParams } from '../modules/wishlist'\nimport NacelleEvents, { NacelleEventsParams } from '../modules/events'\nimport { NacelleConnector } from '../connectors/nacelleConnector'\nimport NacelleStaticConnector from '../connectors/static/nacelleStaticConnector'\nimport NacelleGraphQLConnector from '../connectors/graphql/nacelleGraphQLConnector'\n\nexport interface NacelleClientParams {\n  token: string\n  id: string\n  nacelleEndpoint: string\n  eventsEndpoint?: string\n  wishlistEndpoint?: string\n  staticBasePath?: string\n  locale?: string\n  useStatic?: boolean\n  debugMode?: boolean\n  disableEvents?: boolean\n}\nexport class NacelleClient {\n  // Settings\n  id: string\n  token: string\n  nacelleEndpoint: string\n  useStatic: boolean\n  debugMode: boolean\n  defaultLocale: string\n\n  // Modules\n  data: NacelleData\n  checkout: NacelleCheckout\n  events: NacelleEvents\n  status: NacelleStatus\n  wishlist: NacelleWishlist\n\n  constructor(params: NacelleClientParams) {\n    if (typeof params.token === 'undefined' || params.token.length === 0) {\n      throw new Error('Nacelle space token is required.')\n    }\n\n    if (typeof params.id === 'undefined' || params.id.length === 0) {\n      throw new Error('Nacelle space id is required.')\n    }\n\n    if (\n      typeof params.nacelleEndpoint === 'undefined' ||\n      params.nacelleEndpoint.length === 0\n    ) {\n      throw new Error('Nacelle endpoint is required')\n    }\n\n    // Set defaults\n    this.id = params.id\n    this.token = params.token\n    this.nacelleEndpoint = params.nacelleEndpoint\n    this.useStatic =\n      typeof params.useStatic !== 'undefined' ? params.useStatic : true\n    this.debugMode =\n      typeof params.debugMode !== 'undefined' ? params.debugMode : false\n    this.defaultLocale =\n      typeof params.locale !== 'undefined' ? params.locale : 'en-us'\n\n    // Set up connectors\n    let dataConnector = new NacelleConnector({\n      locale: this.defaultLocale,\n    })\n\n    const staticConnector = new NacelleStaticConnector({\n      basePath: params.staticBasePath,\n      locale: this.defaultLocale,\n    })\n\n    const graphQLConnector = new NacelleGraphQLConnector({\n      endpoint: this.nacelleEndpoint,\n      spaceId: this.id,\n      token: this.token,\n      locale: this.defaultLocale,\n    })\n\n    // Setup Data module\n    if (this.useStatic) {\n      dataConnector = staticConnector\n    } else {\n      dataConnector = graphQLConnector\n    }\n\n    this.data = new NacelleData({\n      connector: dataConnector,\n      locale: this.defaultLocale,\n    })\n\n    // Setup Checkout Module\n    this.checkout = new NacelleCheckout({\n      connector: graphQLConnector,\n    })\n\n    // Setup Status Module\n    this.status = new NacelleStatus({\n      connector: graphQLConnector,\n    })\n\n    // Setup Events Module\n    const eventParams: NacelleEventsParams = {}\n\n    if (params.eventsEndpoint) {\n      eventParams.endpoint = params.eventsEndpoint\n    }\n\n    if (params.disableEvents) {\n      eventParams.disable = params.disableEvents\n    }\n\n    this.events = new NacelleEvents(eventParams)\n\n    // Setup WishList module\n    const wishlistParams: NacelleWishlistParams = {\n      spaceId: this.id,\n      token: this.token,\n    }\n\n    if (params.wishlistEndpoint) {\n      wishlistParams.endpoint = params.wishlistEndpoint\n    }\n\n    this.wishlist = new NacelleWishlist(wishlistParams)\n  }\n}\n"],"names":["_Pact","prototype","then","onFulfilled","onRejected","result","state","this","s","callback","_settle","v","e","o","_this","value","pact","bind","observer","_isSettledPact","thenable","_iteratorSymbol","Symbol","iterator","_catch","body","recover","asyncIterator","NacelleData","params","connector","locale","currencyCode","afterSubscriptions","onDataError","updateDefaults","update","product","_this2","applyAfter","error","method","products","_this4","collection","_this6","collectionPage","_this8","content","_this10","page","_this12","pages","_this14","article","_this16","articles","_this18","blog","_this20","blogPage","_this22","space","_this24","allProducts","_this26","allCollections","_this28","collections","allContent","_this30","after","push","responseObj","response","target","check","step","reject","_cycle","next","done","return","_fixup","TypeError","values","i","length","array","_forTo","filter","sub","EventType","HttpClientAxios","options","client","axios","create","responseType","headers","timeout","maxContentLength","get","url","post","data","NacelleConnector","apiClient","httpClient","_options","Error","lists","paginate","index","itemsPerPage","list","selectedList","selected","find","slug","undefined","getList","handles","slice","createProduct","id","handle","globalHandle","pimSyncSourceDomain","title","description","priceRange","min","max","availableForSale","tags","media","metafields","variants","indexedAt","createMedia","type","src","thumbnailSrc","altText","createItemList","obj","createCollection","productLists","featuredMedia","Array","isArray","map","createContent","articleLists","sections","cmsSyncSource","cmsSyncSourceDomain","cmsSyncSourceContentId","relatedArticles","formattedSections","JSON","parse","section","fieldTags","reduce","fields","tag","includes","split","mapContentSections","createSpace","linklists","name","domain","NacelleGraphQLConnector","endpoint","spaceId","token","request","query","queryName","variables","_this3","errors","firstError","pop","message","success","stringify","getAllPageItems","arr","items","concat","test","awaitBody","shouldContinue","_resumeAfterBody","_resumeAfterTest","_this5","first","nextToken","useLocale","_this9","requests","Promise","all","responses","getListHandles","_this13","blogHandle","_this17","_this19","_this21","limit","entry","processCheckout","input","queryCheckout","isVariantAvailable","NacelleCheckout","process","NacelleStatus","NacelleWishlist","env","NACELLE_WISHLIST_ENDPOINT","put","NacelleEvents","NACELLE_TEM_ENDPOINT","disable","subscriptions","attributionEvents","log","eventInput","updateSessionEventCount","event","user","device","getDevice","getUrlParts","getGlobalEventData","getAttributionData","eventType","setGlobalEventData","attributionType","attributionData","modifiedEvent","acc","cur","eventToSend","onAttributionEvent","onEvent","globalScope","getGlobalScope","navigator","userAgent","toLowerCase","href","location","parsedUrl","tryCatch","URL","urlParams","search","replace","x","toString","hostname","route","pathname","globalThis","window","global","nacelleEventData","globalEventData","sessionEventCount","tryFunc","catchFunc","defaultTypes","formattedLocal","path","indexOf","prefix","parentHandle","constructDataPathPrefix","NacelleStaticConnector","basePath","requestMany","paths","constructDataPath","_this7","onError","_this11","_this15","nacelleEndpoint","useStatic","debugMode","defaultLocale","staticConnector","staticBasePath","graphQLConnector","checkout","status","eventParams","eventsEndpoint","disableEvents","events","wishlistParams","wishlistEndpoint","wishlist"],"mappings":"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"}